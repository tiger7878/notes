1、查询
	查询表的字段信息：SHOW FULL COLUMNS FROM 表名
	查询表中所有字段到一列：select group_concat(COLUMN_NAME) from information_schema.COLUMNS where table_name = '表名';
	获取当前日期: select curdate(); 
	获取当月最后一天: select last_day(curdate());   
	获取本月第一天: select DATE_ADD(curdate(),interval -day(curdate())+1 day); 
	获取下个月的第一天: select date_add(curdate()-day(curdate())+1,interval 1 month); 
	获取当前月的天数: select DATEDIFF(date_add(curdate()-day(curdate())+1,interval 1 month ),DATE_ADD(curdate(),interval -day(curdate())+1 day)) from dual;

2、表修改
	表添加字段
	alter table   table1 add id int unsigned not Null auto_increment primary key
	
	-- 在test_table 表的 valid_status 字段之后，新增一个字段，设置对应的类型，长度，是否为null，默认值，注释
	ALTER TABLE test_table ADD COLUMN `is_staff` tinyint(2) NOT NULL DEFAULT '0' COMMENT '是否是从业人员 0否 1是' AFTER `valid_status`;
	
	-- 修改一个字段的类型
	ALTER TABLE test_table MODIFY test_value VARCHAR(10) NOT NULL DEFAULT '' COMMENT '字段注释';
	 
	-- 修改一个字段的名称，此时要重新指定该字段的类型
	ALTER TABLE test_table CHANGE test_value_old test_value_new VARCHAR(10) NOT NULL DEFAULT '' COMMENT '字段注释';
	
	-- 删除test_table表的 test_value字段 
	ALTER TABLE test_table DROP COLUMN test_value;
	
	-- 添加索引
	ALTER TABLE table_name ADD INDEX index_name (column) 
	
3、关联更新
	UPDATE del_sheet1 a
	JOIN bi_enterprise_info b ON a.enterprise_name=b.enterprise_name
	SET a.score=b.score
	
4、日期
	格式化：date_format(sysdate(),'%Y-%m-%d') 得到的是：年-月-日
	
5、性能优化
	explain 来判断执行是否需要优化
	type：为all 的时候代表全部扫描，需要优化
	extra：Using temporary，Using filesort，Using where 需要优化
	最左前缀法则：
		联合索引创建时注意索引的字段的先后顺序，因为创建索引树的时候会根据先后顺序来创建，查询时可以不用按照顺序写
		联合索引的所有字段用上或者用到第一个字段也会走索引，否则全表扫描，
		范围查找之后的索引字段是不会再走索引了
		可以看key_len判断走了几个索引字段
	不要在索引列做任何操作（计算，函数，类型转换），这些都会导致索引失效
	日期类型：对于有datetime类型的数据加索引以后，要想选择某个天或者某区间的数据，不要用日期函数，要用大于小于这些比较方法就可以走索引
	索引个数：一张表的单个索引越多，新增，修改时越慢，联合索引可以解决这个问题，但是联合索引的使用要注意顺序和个数
	不等于、is null 、is not null 走全表扫描
	like通配符，针对%在右边可以走索引。如果一定要用like %%，那么就用查询联合所有中的字段就会走索引，如果查询的字段超出了联合索引可以使用搜索引擎比如ElasticSearch
	字符串如果不加单银行也会导致索引失效
	建表建议：不要给字段用null，一般都要给一个默认的值，整形就是0，可以为空的就给空字符串
	
	
	