1、环境准备：
	JDK、IDEA、MYSQL
	MYSQL下载地址：https://dev.mysql.com/downloads/ 
		服务端：MySQL Community Server
		客户端：MySQL Workbench
		
2、版本控制
	spring io：用于管理maven引入的各种jar包的版本，保证了兼容性
	spring cloud：微服务相关的jar的版本
	
3、打包
	在父项目上执行：clean package -Dmaven.test.skip=true 就可以把所有项目打包
	打包所有的jar到一个jar包中，是一个可执行的jar，需要在某个项目的pom.xml中加入以下代码：
	<build>
        <plugins>
            <!--有了这个插件，在maven打包时会把所有jar包打包到一起，否则只是链接-->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>1.3.3.RELEASE</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
        <!--指定打包的项目的名字-->
        <finalName>demo</finalName>
    </build>
	
4、Restfull
	用url来描述资源：/user/1
	用http方法来描述行为：get、post、put、delete
	使用json交互数据
	它只是一种风格，不是一种强制的标准
	jsonPath表达式：https://github.com/json-path/JsonPath
	RequestMapping的value值里面可以写正则表达式：
		@RequestMapping(value = "/user2/{id:\\d+}",method = RequestMethod.GET)
	@GetMapping和@PostMapping可以简化代码
	@RequestBody可以把请求的json字符串转换成实体对象中的属性值
		public User create(@RequestBody User user){}
	日期类型数据处理：前后台传递用时间戳
		
5、JsonView
	控制不同的视图查询相同的实体时，显示的字段不一致
	在实体类中定义两个视图接口
	在实体类的get方法中标注JsonView关联视图接口
	在控制器的方法上标注JsonView指定视图接口

6、数据校验hibernate validator
	@Valid：校验实体的属性值
		public User create(@Valid @RequestBody User user){}
	@BindingResult：加上这个参数后，校验不通过也能进入方法，可以收集所有错误信息，没有该参数时，校验不通过就不进入该方法
	@NotBlank：不能为空
	@Past：过去的时间
	自定义错误校验：
		校验注解：必须要有message、groups、payload三个方法
		校验类：需要实现ConstraintValidator<A,T>接口。它是spring的一个bean，可以注入其他spring容器中的bean。
		
7、Spring Boot服务异常处理
	出现异常时：spring boot判断请求是否是浏览器，如果是就响应html，如果不是就响应json。源码见：BasicErrorController中的方法
	自定义异常页面：（适用于浏览器请求）
		在resources下创建resources/error目录，然后新建404.html，这就是404的页面。它影响的浏览器的请求，不影响非浏览器的请求。
	自定义异常响应：（适用于非浏览器请求）
		自定义异常类继承：RuntimeException类，然后写自己的属性和方法
		@ControllerAdvice：拦截控制器上的所有异常，标注处理自定义异常的类

8、RestfullAPI的拦截
	过滤器：Filter（缺点：不知道请求是哪个控制器，哪个方法来处理的）
		自定义过滤器需要实现Filter接口，并且标注@Component，所有的url请求都会经过这个过滤器。可以通过自定义Bean来控制某些url才经过。
		第三方过滤器：没有办法直接在它们的类上标注@Component，就必须在配置类中定义FilterRegistrationBean
	拦截器：Interceptor（缺点：不能拿到请求的方法的参数值）
		自定义拦截器需要实现：HandlerInterceptor接口，同时标注：@Component注解
		配置类：继承WebMvcConfigurerAdapter，重写：addInterceptors方法进行注册
		优点：spring框架本身提供的，可以知道是哪个控制器，哪个方法被拦截了。它会拦截自己写的controller也会拦截spring自己的controller
	切片：Aspect
		优点：可以替代上面两种，可以拿到请求的参数的值
	拦截顺序：Filter→Interceptor→ControllerAdvice→Aspect→Controller。如果Controller出异常就是反着出去。
	
9、文件上传和下载
	JDK7新语法：在try的（）中写流，可以帮我们自动关闭，不用在catch和finally中关闭了
		try (InputStream inputStream = new FileInputStream(new File(folder, id + ".txt"));
				OutputStream outputStream = response.getOutputStream();) {}

10、多线程提高RestfullAPI性能
	 Runnable：使用Callable在主线程里面写代码调用子线程。实用性不大。
	 DeferredResut：（很有用，待完善）用户请求到action，在action中请求消息队列，另外有一个线程监听消息队列，当消息队列处理完成后，监听线程把结果返回，实际是异步，但是用户无感知。
	 
11、Swagger自动生成html文档
	依赖：
		<dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.7.0</version>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
            <version>2.7.0</version>
        </dependency>
	启用注解：@EnableSwagger2
	使用环境：@Profile({"dev","test"}) //指定在开发和测试环境中才启用swagger，生产环境中禁用
	访问地址：http://localhost:8080/swagger-ui.html

12、WireMock伪造REST服务
	它是一个独立的服务器，在收到请求时响应数据回去
	下载网址：http://wiremock.org/docs/running-standalone/
	启动服务端：java -jar wiremock-standalone-2.19.0.jar --port 8062
	依赖：
		<dependency>
			<groupId>com.github.tomakehurst</groupId>
			<artifactId>wiremock</artifactId>
		</dependency>
13、Spring Security基本原理
	它本质是过滤器链，请求和响应都要经过
	重要的过滤器：
		UsernamePasswordAuthenticationFilter：用户名密码认证方式的过滤器
		BasicAuthenticationFilter：Basic认证方式的过滤器
		ExceptionTranslationFilter：异常处理的过滤器
		FilterSecurityInterceptor：安全的拦截器，它来判断能否访问服务器上的资源
	
14、自定义用户认证
	处理用户信息获取的逻辑
		自定义用户信息获取类，需要实现：UserDetailsService接口
	处理用户校验逻辑
		UserDeails接口中的几个方法介绍：
			isAccountNonExpired()：账户是否有过期
			isAccountNonLocked()：账户是否被锁定了，可以用来锁定账号。
			isCredentialsNonExpired()：密码是否过期，安全级别高的网站，30天要求变化密码时用。
			isEnabled()：账户是否可用，用于假删除，删除的用户不能恢复。
	处理密码加解密的逻辑
		PasswordEncoder：它随机生成盐和密码以前加密，相同的原始密码，每次加密得到的结果都是不同的，推荐使用这个。（思路不错）
		
15、个性化用户认证流程
	自定义登录页：专门的类（BrowserSecurityController）来处理登录时的页面跳转提示 
	自定义登录成功处理：自定义类继承SavedRequestAwareAuthenticationSuccessHandler类
	自定义登录失败处理：自定义类继承SimpleUrlAuthenticationFailureHandler类
	获取认证的用户信息：SecurityContextHolder里面
	
16、图形验证码
	图片验证码类：ImageCode
	验证码生成接口：ValidateCodeGenerator、图片验证码生成类：ImageCodeGenerator
	验证码配置类：ValidateCodeProperites、图片验证码配置类：ImageCodeProperties
	验证码异常类：ValidateCodeException
	验证码过滤器：ValidateCodeFilter
	验证码实体Bean配置类：ValidateCodeBeanConfig
	默认验证码输出控制器：ValidateCodeController
	
17、有用的工具类
	ServletWebRequest：封装了request和response。转换：new ServletWebRequest(HttpServletRequest request)
	SessionStrategy：对session的操作。包：spring-social
	RedirectStrategy：跳转redirect工具。包：spring-security
	ServletRequestUtils：从request获取请求参数的值，例如：ServletRequestUtils.getStringParameter(request.getRequest(), "imageCode")
	StringUtils：对String的操作，比如equals，isblank等。包：commons-lang
	AntPathMatcher：用于ant的匹配。比如/user/*的匹配。
	PasswordEncoder：用于密码加密，相同的明文每次加密得到不同的结果。包spring-security
	
	
	
	