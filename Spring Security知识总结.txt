1、环境准备：
	JDK、IDEA、MYSQL
	MYSQL下载地址：https://dev.mysql.com/downloads/ 
		服务端：MySQL Community Server
		客户端：MySQL Workbench
		
2、版本控制
	spring io：用于管理maven引入的各种jar包的版本，保证了兼容性
	spring cloud：微服务相关的jar的版本
	
3、打包
	在父项目上执行：clean package -Dmaven.test.skip=true 就可以把所有项目打包
	打包所有的jar到一个jar包中，是一个可执行的jar，需要在某个项目的pom.xml中加入以下代码：
	<build>
        <plugins>
            <!--有了这个插件，在maven打包时会把所有jar包打包到一起，否则只是链接-->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <version>1.3.3.RELEASE</version>
                <executions>
                    <execution>
                        <goals>
                            <goal>repackage</goal>
                        </goals>
                    </execution>
                </executions>
            </plugin>
        </plugins>
        <!--指定打包的项目的名字-->
        <finalName>demo</finalName>
    </build>
	
4、Restfull
	用url来描述资源：/user/1
	用http方法来描述行为：get、post、put、delete
	使用json交互数据
	它只是一种风格，不是一种强制的标准
	jsonPath表达式：https://github.com/json-path/JsonPath
	RequestMapping的value值里面可以写正则表达式：
		@RequestMapping(value = "/user2/{id:\\d+}",method = RequestMethod.GET)
	@GetMapping和@PostMapping可以简化代码
	@RequestBody可以把请求的json字符串转换成实体对象中的属性值
		public User create(@RequestBody User user){}
	日期类型数据处理：前后台传递用时间戳
		
5、JsonView
	控制不同的视图查询相同的实体时，显示的字段不一致
	在实体类中定义两个视图接口
	在实体类的get方法中标注JsonView关联视图接口
	在控制器的方法上标注JsonView指定视图接口

6、数据校验hibernate validator
	@Valid：校验实体的属性值
		public User create(@Valid @RequestBody User user){}
	@BindingResult：加上这个参数后，校验不通过也能进入方法，可以收集所有错误信息，没有该参数时，校验不通过就不进入该方法
	@NotBlank：不能为空
	@Past：过去的时间
	自定义错误校验：
		校验注解：必须要有message、groups、payload三个方法
		校验类：需要实现ConstraintValidator<A,T>接口。它是spring的一个bean，可以注入其他spring容器中的bean。
		
7、Spring Boot服务异常处理
	出现异常时：spring boot判断请求是否是浏览器，如果是就响应html，如果不是就响应json。源码见：BasicErrorController中的方法
	自定义异常页面：（适用于浏览器请求）
		在resources下创建resources/error目录，然后新建404.html，这就是404的页面。它影响的浏览器的请求，不影响非浏览器的请求。
	自定义异常响应：（适用于非浏览器请求）
		自定义异常类继承：RuntimeException类，然后写自己的属性和方法
		@ControllerAdvice：拦截控制器上的所有异常，标注处理自定义异常的类

8、RestfullAPI的拦截
	过滤器：Filter（缺点：不知道请求是哪个控制器，哪个方法来处理的）
		自定义过滤器需要实现Filter接口，并且标注@Component，所有的url请求都会经过这个过滤器。可以通过自定义Bean来控制某些url才经过。
		第三方过滤器：没有办法直接在它们的类上标注@Component，就必须在配置类中定义FilterRegistrationBean
	拦截器：Interceptor（缺点：不能拿到请求的方法的参数值）
		自定义拦截器需要实现：HandlerInterceptor接口，同时标注：@Component注解
		配置类：继承WebMvcConfigurerAdapter，重写：addInterceptors方法进行注册
		优点：spring框架本身提供的，可以知道是哪个控制器，哪个方法被拦截了。它会拦截自己写的controller也会拦截spring自己的controller
	切片：Aspect
		优点：可以替代上面两种，可以拿到请求的参数的值
	拦截顺序：Filter→Interceptor→ControllerAdvice→Aspect→Controller。如果Controller出异常就是反着出去。
	
9、文件上传和下载
	JDK7新语法：在try的（）中写流，可以帮我们自动关闭，不用在catch和finally中关闭了
		try (InputStream inputStream = new FileInputStream(new File(folder, id + ".txt"));
				OutputStream outputStream = response.getOutputStream();) {}

10、多线程提高RestfullAPI性能
	 Runnable：使用Callable在主线程里面写代码调用子线程。实用性不大。
	 DeferredResut：（很有用，待完善）用户请求到action，在action中请求消息队列，另外有一个线程监听消息队列，当消息队列处理完成后，监听线程把结果返回，实际是异步，但是用户无感知。
	 
11、Swagger自动生成html文档
	依赖：
		<dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger2</artifactId>
            <version>2.7.0</version>
        </dependency>
        <dependency>
            <groupId>io.springfox</groupId>
            <artifactId>springfox-swagger-ui</artifactId>
            <version>2.7.0</version>
        </dependency>
	启用注解：@EnableSwagger2
	使用环境：@Profile({"dev","test"}) //指定在开发和测试环境中才启用swagger，生产环境中禁用
	访问地址：http://localhost:8080/swagger-ui.html

12、WireMock伪造REST服务
	它是一个独立的服务器，在收到请求时响应数据回去
	下载网址：http://wiremock.org/docs/running-standalone/
	启动服务端：java -jar wiremock-standalone-2.19.0.jar --port 8062
	依赖：
		<dependency>
			<groupId>com.github.tomakehurst</groupId>
			<artifactId>wiremock</artifactId>
		</dependency>
13、Spring Security基本原理
	它本质是过滤器链，请求和响应都要经过
	重要的过滤器：
		UsernamePasswordAuthenticationFilter：用户名密码认证方式的过滤器
		BasicAuthenticationFilter：Basic认证方式的过滤器
		ExceptionTranslationFilter：异常处理的过滤器
		FilterSecurityInterceptor：安全的拦截器，它来判断能否访问服务器上的资源
	
14、自定义用户认证
	处理用户信息获取的逻辑
		自定义用户信息获取类，需要实现：UserDetailsService接口
	处理用户校验逻辑
		UserDeails接口中的几个方法介绍：
			isAccountNonExpired()：账户是否有过期
			isAccountNonLocked()：账户是否被锁定了，可以用来锁定账号。
			isCredentialsNonExpired()：密码是否过期，安全级别高的网站，30天要求变化密码时用。
			isEnabled()：账户是否可用，用于假删除，删除的用户不能恢复。
	处理密码加解密的逻辑
		PasswordEncoder：它随机生成盐和密码以前加密，相同的原始密码，每次加密得到的结果都是不同的，推荐使用这个。（思路不错）
		
15、个性化用户认证流程
	自定义登录页：专门的类（BrowserSecurityController）来处理登录时的页面跳转提示 
	自定义登录成功处理：自定义类继承SavedRequestAwareAuthenticationSuccessHandler类
	自定义登录失败处理：自定义类继承SimpleUrlAuthenticationFailureHandler类
	获取认证的用户信息：SecurityContextHolder里面
	
16、图形验证码
	图片验证码类：ImageCode
	验证码生成接口：ValidateCodeGenerator、图片验证码生成类：ImageCodeGenerator
	验证码配置类：ValidateCodeProperites、图片验证码配置类：ImageCodeProperties
	验证码异常类：ValidateCodeException
	验证码过滤器：ValidateCodeFilter
	验证码实体Bean配置类：ValidateCodeBeanConfig
	默认验证码输出控制器：ValidateCodeController
	
17、有用的工具类
	ServletWebRequest：封装了request和response。转换：new ServletWebRequest(HttpServletRequest request)
	SessionStrategy：对session的操作。包：spring-social
	RedirectStrategy：跳转redirect工具。包：spring-security
	ServletRequestUtils：从request获取请求参数的值，例如：ServletRequestUtils.getStringParameter(request.getRequest(), "imageCode")
	StringUtils：对String的操作，比如equals，isblank等。包：commons-lang
	AntPathMatcher：用于ant的匹配。比如/user/*的匹配。
	PasswordEncoder：用于密码加密，相同的明文每次加密得到不同的结果。包spring-security
	RandomStringUtils：用于生存随机的字符串
	RestTemplate：请求rest服务时的工具
	ObjectMapper：把json格式的字符串转换为实体对象
	
18、短信验证码
	短信验证码类：SmsCode
	验证码处理接口：ValidateCodeProcessor
	验证码处理接口抽象实现类：AbstractValidateCodeProcessor
	验证码生成接口：ValidateCodeGenerator、短信验证码生成类：SmsCodeGnenerator
	图片验证码处理类：ImageCodeProecessor
	短信验证码处理类：SmsCodeProcessor
	短信验证码发送接口：SmsCodeSender、短信验证码发送接口默认实现类：DefaultSmsCodeSender
	
19、依赖查找
	@Autowired
	private Map<String,ValidateCodeGenerator> validateCodeGennerators;
	spring发现有这个时，会把spring容器中，所有ValidateCodeGenerator它的实现和bean的名字存到这里
	
20、短信登录
	短信认证的token(包含了认证信息)：SmsCodeAuthenticationToken。参考：UsernamePasswordAuthenticationToken编写。
	短信认证的过滤器：SmsCodeAuthenticationFilter。参考：UsernamePasswordAuthenticationFilter编写。
	短信认证的校验逻辑：SmsCodeAuthenticationProvider，要实现AuthenticationProvider接口，它的supports方法是用来判断是否用该类来处理校验逻辑。参考：AbstractUserDetailsAuthenticationProvider编码。
	短信登录验证的过滤器：SmsCodeFilter。参考：ValidateCodeFilter编写。
	
21、验证码重构
	验证码类型：ValidateCodeType，用于标识图片，还是短信验证码。它设计得巧妙，很多地方都有使用它来获取相关的类。
	验证码过滤器：ValidateCodeFilter，负责装载需要验证码验证的url和对应的验证码类型，处理时交给对应的验证码处理器进行处理
	验证码处理器的控制器：ValidateCodeProcessorHolder，负责根据验证码类型获取对应的验证码处理器
	验证码处理器：ValidateCodeProcessor，负责创建(创建、保存、发送)和校验验证码
	验证码处理器的实现类：AbstractValidateCodeProcessor（抽象类）、ImageCodeProcessor（图片验证码处理器）、SmsCodeProcessor（短信验证码处理器）
	安全配置类：AbstractChannelSecurityConfig，用来封装formLogin的，以便其他配置类继承，配置文件分层思想，通过apply引入其他配置类
	常量配置接口：SecurityConstants，里面封装了所有的常量
	
	特别重要：
		字符串、实体类、依赖查找配合起来一起使用，相当灵活。
		配置类分层处理。

22、OAuth简介
	OAuth协议中的授权模式：授权码模式（authorization code）、简化模式（implicit）、密码模式（password）、客户端模式（client credentials）
	
23、Spring Social第三方登录
	服务提供商：ServiceProvider（默认实现：AbstractOAuth2ServiceProvider）
	获取用户信息：Api(默认实现：AbstractOAuth2ApiBinding)
	OAuth协议中相关的，封装了OAuth2协议处理的流：OAuth2Operations（默认实现OAuth2Template）
	API的适配器：ApiAdapter

24、Session管理
		Session超时处理
			server.session.timeout=120 #单位是秒，session超时时间，在spring boot中session超时时间最少是1分钟，看源码可知道
		Session并发控制
			方式一：相同的账号，首先在A浏览器登录，然后在B浏览器再登录时把A浏览器上的账号T下线。
			方式二：相同的账号，首先在A浏览器登录，然后在B浏览器登录时就不能登录。加maxSessionPreventsLogin(true)配置
		集群Session管理
			把session存储到独立的服务器，此时往session里面放的数据需要实现Serializable接口，因为需要序列化以后再存放
			使用spring-session+Redis（4.0的稳定版）
			yml配置文件：spring.session.store-type=redis
			说明：集群后，上面的Session失效和并发策略仍然有效
		退出处理
			.logout()
                .logoutUrl("/signOut")//自定义退出的url地址，默认logout
                .logoutSuccessHandler(MonkeyLogoutSuccessHander)//自定义退出成功后的控制器，需要实现LogoutSuccessHandler接口
				.logoutSuccessUrl("/xx.html")//自定义退出成功后的跳转页面，它和logoutSuccessHandler只能同时存在一个
				
25、Spring Security OAtuth
	OAtuth 2官网：https://oauth.net/2/
	Authorization Server : 认证服务器，负责认证和授权。@EnableAuthorizationServer 注解标注即可
	Resource Server ：资源服务器，存放资源的服务器。@EnableResourceServer 注解标注即可。实际开发中认证服务器可以和资源服务器是同一台。
	clientId ：应用id，每个应用分配一个id，这样我就知道是哪个引用来请求授权。比如：微信和QQ就是两个不同的应用。
	clientSecret ：应用的密钥。
	basic认证：需要填写clientId和clientSecret，这样就能确定这个应用可以请求认证服务器。
	grant_type ：4种授权模式。password模式可以用于本公司开发的应用。
	scope ：授权范围
	access_token ：访问令牌，同一个用户，在某个令牌还没有失效以前，请求其他的授权模式获取到的令牌是同一个，因为认证服务器会判断。
	访问角色：默认情况下需要有ROLE_USER角色才能访问，需要在MyUserDetailsService中添加它，否则不能访问
	获取code：http://localhost:8080/oauth/authorize?response_type=code&client_id=mkapp&redirect_uri=http://monkey78.com&scope=all
	
26、Spring Security OAtuth源码分析
	TokenEndpoint：入口点，它有/oauth/token方法
	ClientDetailsService：它是用来读取第三方应用信息的，默认实现是InMemoryClientDetailsService。
	ClientDetails：第三方应用的信息，我们可以对第三方应用进行很多项的配置。
	TokenRequest：封装了 grant_type、scope等请求/oauth/token时的参数和值 相关信息
	TokenGranter：令牌授权者，它封装了4种授权模式（授权码、密码等）的不同实现，它根据grant_type创建对应的授权默认的实现。默认实现是CompositeTokenGranter。
	OAtuth2Request：它是ClientDetails和TokenRequest的整合
	Authorization：封装的是当前授权用户的一些信息，主要是通过UserDetailsService根据用户名从数据库中读取出来的。
	OAtuth2Authorization：它是OAtuth2Request和Authorization的整合对象。它里面包含了：第三方应用、授权码模式，授权用户等信息。
	AuthorizationServerTokenServices ：认证服务器的令牌服务，生成和刷新令牌，默认实现是DefaultTokenServices，包含：TokenStore（令牌存取）、TokenEnhancer（令牌增强器）。
	OAtuth2AccessToken：令牌
	
27、重构3中登录方式
	BasicAuthenticationFilter：Basic认证方式的过滤器，参考它获取一些basic认证的信息
	MonkeyAuthenticationSuccessHandler：方法写在这里
	获取：ClientDetails
	创建：TokenRequest
	创建：OAtuth2Request
	创建：OAtuth2Authorization
	创建：OAtuth2AccessToken
	重构图片和短信验证码：
		在请求参数中加入deviceId即可，以它作为key保存到redis中，生成和校验验证码时都带上这个deviceId
		新创建一个接口ValidateCodeRepository，对验证码保存、查询、删除操作，由app和browser两个模块具体实现：RedisValidateCodeRepository和SessionValidateCodeRepository
		待解决问题：由于key生成的策略导致所有用户的key都是同一个，大家同时登录时只有最后一个人可以登录成功，因为其他人的验证码key中的值都被覆盖了。
			个人认为可以把用户名作为key的一部分，这样就避免了所有用户使用相同的key
28、Token的配置
	MonkeyAuthorizationServerConfig：自定义认证服务器配置类，实现AuthorizationServerConfigurerAdapter接口
		重写endpoints作为参数的方法：配置：AuthenticationManager、UserDetailsService、TokenStore
		重写clients作为参数的方法：对应用做配置，决定可以给哪些应用发令牌，可以配置多个。可以保存在内存、数据库、redis中
		TokenStore令牌存储：推荐存储到redis中，可以在令牌失效后自动删除，不用我们维护，而且性能比数据库快很多。

29、JWT（Json Web Token）
	特点：
		自包含：包含了一些信息
		密签：信息是被签名了，不是加密的，别人能破解，不能存放业务敏感信息
		可扩展：支持自定义的扩展
	JwtAccessTokenConverter：生成jwtToken，它可以指定密钥对信息进行签名，密钥很重要，别人拿到以后就可以随意进入系统。
	@ConditionalOnProperty：
			配置文件中 monkey.security.oauth2.storeType=redis时才采用这个配置
			@ConditionalOnProperty(prefix = "monkey.security.oauth2", name = "storeType", havingValue = "redis")
			
			配置文件中 monkey.security.oauth2.storeType=jwt时就采用这个配置，matchIfMissing表示如果没有配置，也采用它
			@ConditionalOnProperty(prefix = "monkey.security.oauth2", name = "storeType", havingValue = "jwt", matchIfMissing = true)
	jwt解析的网站：https://www.jsonwebtoken.io/
	扩展：
		自定义MonkeyJwtTokenEnhancer，实现TokenEnhancer，在里面写附加信息
	读取令牌里面的信息
		依赖：
			<dependency>
				<groupId>io.jsonwebtoken</groupId>
				<artifactId>jjwt</artifactId>
				<version>0.9.0</version>
			</dependency>
		从request的请求头中获取到jwtToken，然后解析
	令牌的刷新
		一般是用户无感知的做法，比如用户用它的token来获取信息时，服务器发现过期了，可以直接刷新一下给用户
		刷新token的有效期可以设置长一些，比如一星期或者一个月都行
		待解决问题：发现刷新令牌后生成的是一个新的token，此时应该把这个token响应回客户端，否则客户端就不知道

30、JWT实现SSO（单点登录）
	说明：用户在某个应用上登录，然后在其他的关联应用上进行资源访问时也处于登录状态，只是不同的应用上获取到的jwtToken是不同的，需要有统一的认证服务器。
	依赖：
		<dependencies>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-security</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.security.oauth</groupId>
            <artifactId>spring-security-oauth2</artifactId>
        </dependency>
        <dependency>
            <groupId>org.springframework.security</groupId>
            <artifactId>spring-security-jwt</artifactId>
        </dependency>
    </dependencies>
	注解：
		@EnableOAuth2Sso
	配置：
		security:
		  oauth2:
			client:
			  client-id: mkapp2
			  client-secret: mkappsecrect2
			  user-authorization-uri: http://127.0.0.1:9999/server/oauth/authorize #认证地址
			  access-token-uri: http://127.0.0.1:9999/server/oauth/token #获取token地址
			resource:
			  jwt:
				key-uri: http://127.0.0.1:9999/server/oauth/token_key #获取签名的token_key的地址
	简化手动点击授权按钮，做成表单自动提交。参考：WhitelabelApprovalEndpoint和SpelView，直接copy，然后修改WhitelabelApprovalEndpoint TEMPLATE。
		